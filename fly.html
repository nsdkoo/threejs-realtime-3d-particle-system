<!DOCTYPE html><html lang="zh-CN"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Hunter - Gesture Control 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; }
        #hud {
            position: fixed; top: 2rem; left: 2rem; right: 2rem;
            pointer-events: none; z-index: 100;
        }
        .stats-box {
            background: rgba(0, 20, 40, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem; border-radius: 4px;
        }
        #crosshair {
            position: fixed; width: 40px; height: 40px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; transition: all 0.1s ease-out;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: cyan; border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .scanline {
            width: 100%; height: 100px; z-index: 5; position: absolute;
            background: linear-gradient(0deg, rgba(0,255,255,0) 0%, rgba(0,255,255,0.05) 50%, rgba(0,255,255,0) 100%);
            opacity: 0.1; pointer-events: none; animation: scan 4s linear infinite;
        }
        @keyframes scan { from { top: -100px; } to { top: 100vh; } }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&amp;display=swap" rel="stylesheet">
</head>
<body>

    <div class="scanline"></div>
    
    <!-- HUD 界面 -->
    <div id="hud" class="flex justify-between items-start">
        <div class="stats-box">
            <div class="text-[10px] text-cyan-400 uppercase tracking-widest">Pilot Status</div>
            <div class="text-2xl font-bold text-white tracking-tighter" id="score-display">SCORE: 0000</div>
            <div class="w-48 h-1 bg-gray-800 mt-2 overflow-hidden">
                <div id="hp-bar" class="h-full bg-cyan-500 transition-all duration-300" style="width: 100%"></div>
            </div>
        </div>
        
        <div class="stats-box text-right">
            <div id="control-mode" class="text-[10px] text-yellow-500 uppercase">Initializing System...</div>
            <div class="text-[10px] text-gray-400 mt-1">
                [PINCH] TO FIRE<br>[MOVE HAND] TO NAVIGATE
            </div>
        </div>
    </div>

    <!-- 准星 -->
    <div id="crosshair"></div>

    <!-- 隐藏视频源 -->
    <video id="input-video" class="hidden"></video>

    <script>
        // --- 核心变量 ---
        let scene, camera, renderer, player, stars;
        let enemies = [];
        let bullets = [];
        let score = 0;
        let hp = 100;
        let isFiring = false;
        let targetPos = { x: 0, y: 0 };
        let currentPos = { x: 0, y: 0 };
        let isUsingMouse = true;

        // --- 初始化场景 ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 500;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 1. 创建玩家战机 (几何发光风格)
            const playerGroup = new THREE.Group();
            const bodyGeo = new THREE.ConeGeometry(10, 40, 4);
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            playerGroup.add(body);

            // 战机引擎光效
            const engineGeo = new THREE.SphereGeometry(5, 8, 8);
            const engineMat = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.5 });
            const engine = new THREE.Mesh(engineGeo, engineMat);
            engine.position.z = 20;
            playerGroup.add(engine);

            player = playerGroup;
            scene.add(player);

            // 2. 环境星空
            const starCount = 3000;
            const starGeo = new THREE.BufferGeometry();
            const starPos = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                starPos[i*3] = (Math.random() - 0.5) * 3000;
                starPos[i*3+1] = (Math.random() - 0.5) * 3000;
                starPos[i*3+2] = (Math.random() - 0.5) * 3000;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 2 }));
            scene.add(stars);

            // 3. 灯光
            const light = new THREE.PointLight(0x00ffff, 1, 1000);
            light.position.set(0, 0, 100);
            scene.add(light);

            window.addEventListener('resize', onWindowResize);
            
            // 鼠标兜底
            window.addEventListener('mousemove', (e) => {
                if(isUsingMouse) {
                    updateTargetPos(e.clientX, e.clientY);
                }
            });
            window.addEventListener('mousedown', () => { if(isUsingMouse) isFiring = true; });
            window.addEventListener('mouseup', () => { if(isUsingMouse) isFiring = false; });
        }

        function updateTargetPos(x, y) {
            targetPos.x = (x / window.innerWidth) * 2 - 1;
            targetPos.y = -(y / window.innerHeight) * 2 + 1;
            
            const crosshair = document.getElementById('crosshair');
            crosshair.style.left = x + 'px';
            crosshair.style.top = y + 'px';
        }

        // --- 游戏逻辑对象 ---
        function spawnEnemy() {
            const geo = new THREE.IcosahedronGeometry(15, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff0066, wireframe: true });
            const enemy = new THREE.Mesh(geo, mat);
            
            enemy.position.x = (Math.random() - 0.5) * 800;
            enemy.position.y = (Math.random() - 0.5) * 600;
            enemy.position.z = -2000;
            
            enemy.userData = { 
                speed: 5 + Math.random() * 10,
                rot: Math.random() * 0.05 
            };
            
            enemies.push(enemy);
            scene.add(enemy);
        }

        function fireBullet() {
            const geo = new THREE.BoxGeometry(2, 2, 20);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const bullet = new THREE.Mesh(geo, mat);
            bullet.position.copy(player.position);
            bullet.position.z -= 20;
            bullets.push(bullet);
            scene.add(bullet);
        }

        // --- 手势识别 ---
        function initHands() {
            const videoElement = document.getElementById('input-video');
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    if(isUsingMouse) {
                        isUsingMouse = false;
                        document.getElementById('control-mode').innerText = "Neural Link Established";
                        document.getElementById('control-mode').className = "text-[10px] text-cyan-400 uppercase";
                    }

                    const landmarks = results.multiHandLandmarks[0];
                    
                    // 1. 位置控制 (食指指尖)
                    const indexTip = landmarks[8];
                    updateTargetPos(indexTip.x * window.innerWidth, indexTip.y * window.innerHeight);

                    // 2. 捏合检测 (大拇指 4 和 食指 8 的距离)
                    const thumbTip = landmarks[4];
                    const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    isFiring = dist < 0.05;

                    // 准星视觉反馈
                    const crosshair = document.getElementById('crosshair');
                    crosshair.style.borderColor = isFiring ? 'rgba(255, 0, 100, 0.8)' : 'rgba(0, 255, 255, 0.5)';
                    crosshair.style.transform = `translate(-50%, -50%) scale(${isFiring ? 0.8 : 1})`;
                }
            });

            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 640, height: 480
            });

            camera.start().catch(() => {
                document.getElementById('control-mode').innerText = "Mouse Control Mode (No Camera)";
            });
        }

        // --- 渲染循环 ---
        let frameCount = 0;
        function animate() {
            requestAnimationFrame(animate);
            frameCount++;

            // 1. 玩家平滑移动
            currentPos.x += (targetPos.x * 400 - currentPos.x) * 0.1;
            currentPos.y += (targetPos.y * 300 - currentPos.y) * 0.1;
            player.position.set(currentPos.x, currentPos.y, 0);
            player.rotation.z = (targetPos.x * 400 - currentPos.x) * -0.01; // 侧倾效果
            player.rotation.y = (targetPos.x * 400 - currentPos.x) * 0.01;

            // 2. 发射子弹
            if (isFiring && frameCount % 5 === 0) {
                fireBullet();
            }

            // 3. 处理子弹
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].position.z -= 50;
                if (bullets[i].position.z < -2000) {
                    scene.remove(bullets[i]);
                    bullets.splice(i, 1);
                }
            }

            // 4. 处理敌人
            if (frameCount % 30 === 0) spawnEnemy();
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.position.z += e.userData.speed;
                e.rotation.x += e.userData.rot;
                e.rotation.y += e.userData.rot;

                // 碰撞检测：子弹击中敌人
                for (let j = bullets.length - 1; j >= 0; j--) {
                    if (bullets[j].position.distanceTo(e.position) < 30) {
                        createExplosion(e.position);
                        scene.remove(e);
                        enemies.splice(i, 1);
                        scene.remove(bullets[j]);
                        bullets.splice(j, 1);
                        score += 100;
                        document.getElementById('score-display').innerText = `SCORE: ${score.toString().padStart(4, '0')}`;
                        break;
                    }
                }

                // 碰撞检测：敌人撞击玩家
                if (e && e.position.distanceTo(player.position) < 40) {
                    hp -= 20;
                    document.getElementById('hp-bar').style.width = hp + '%';
                    scene.remove(e);
                    enemies.splice(i, 1);
                    if(hp <= 0) gameOver();
                }

                // 移除飞过的敌人
                if (e && e.position.z > 600) {
                    scene.remove(e);
                    enemies.splice(i, 1);
                }
            }

            // 5. 背景星空滚动
            stars.position.z += 2;
            if (stars.position.z > 1000) stars.position.z = 0;

            renderer.render(scene, camera);
        }

        function createExplosion(pos) {
            const particleCount = 10;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount*3; i++) positions[i] = (Math.random()-0.5)*20;
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const p = new THREE.Points(geo, new THREE.PointsMaterial({color: 0xff0066, size: 2}));
            p.position.copy(pos);
            scene.add(p);
            setTimeout(() => scene.remove(p), 500);
        }

        function gameOver() {
            alert("Mission Failed! Score: " + score);
            hp = 100;
            score = 0;
            document.getElementById('hp-bar').style.width = '100%';
            document.getElementById('score-display').innerText = "SCORE: 0000";
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 启动
        init();
        initHands();
        animate();
    </script>


</body></html>